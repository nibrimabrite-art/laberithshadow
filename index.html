<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Runa: Laberinto de Sombras</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400;600&display=swap');

        :root {
            --bg-dark: #020617;
            --primary-magic: #a855f7;
            --accent-star: #facc15;
            --danger-shadow: #ef4444;
        }

        body {
            background-color: var(--bg-dark);
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 0.5rem;
            overflow: hidden;
            touch-action: none;
        }

        .game-header {
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .game-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: var(--primary-magic);
            letter-spacing: 0.3em;
            margin: 0;
            text-shadow: 0 0 15px rgba(168, 85, 247, 0.6);
        }

        .status-bar {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            width: 100%;
            max-width: 500px;
            margin-bottom: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 0.75rem;
            border: 1px solid rgba(168, 85, 247, 0.3);
            font-size: 0.75rem;
        }

        .battery-track {
            width: 100%;
            max-width: 70px;
            height: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #battery-fill {
            height: 100%;
            width: 100%;
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
            transition: width 0.2s linear, background 0.3s;
        }

        #game-container {
            position: relative;
            background: #000;
            border: 2px solid rgba(168, 85, 247, 0.4);
            border-radius: 1rem;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 450px;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 55vh;
            image-rendering: pixelated;
        }

        #overlay {
            position: absolute;
            inset: 0;
            background: rgba(2, 6, 23, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            padding: 2rem;
            backdrop-filter: blur(4px);
        }

        .btn-primary {
            background: var(--primary-magic);
            color: white;
            padding: 0.75rem 2.5rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 700;
            margin-top: 1.5rem;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
        }

        #mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 1rem;
            width: 100%;
            max-width: 300px;
            z-index: 10;
        }

        .control-btn {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            color: white;
            height: 60px;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }

        .control-btn:active {
            background: var(--primary-magic);
            transform: scale(0.95);
        }

        .magic-btn {
            background: rgba(250, 204, 21, 0.1);
            border-color: rgba(250, 204, 21, 0.4);
            color: var(--accent-star);
        }

        .magic-btn:active {
            background: var(--accent-star);
            color: black;
        }

        #initials-input {
            background: rgba(255,255,255,0.05);
            border: none;
            border-bottom: 2px solid var(--primary-magic);
            color: white;
            font-size: 2rem;
            width: 120px;
            text-align: center;
            outline: none;
            text-transform: uppercase;
            margin: 1.5rem 0;
            font-family: 'Playfair Display', serif;
        }

        .hidden { display: none !important; }

        @media (min-width: 768px) {
            #mobile-controls { display: none; }
        }
    </style>
</head>
<body>

    <header class="game-header">
        <h1 class="game-title">RUNA</h1>
    </header>

    <div class="status-bar">
        <div class="flex flex-col items-start">
            <div class="flex items-center gap-1 text-purple-400 font-bold uppercase tracking-tighter">
                <i data-lucide="map" class="w-3 h-3"></i>
                NIVEL <span id="level-val">1</span>
            </div>
            <div class="text-[9px] text-slate-500 font-mono">ETAPAS: <span id="stages-val">0</span></div>
        </div>
        
        <div class="flex flex-col items-center gap-1">
            <div class="flex items-center gap-1 text-yellow-400" id="star-status">
                <i data-lucide="sparkles" class="w-3 h-3"></i>
                <span class="font-bold text-[10px]" id="stars-count">2</span>
            </div>
            <div class="battery-track">
                <div id="battery-fill"></div>
            </div>
        </div>

        <div class="flex flex-col items-end">
            <div class="text-[10px] text-yellow-500 font-bold uppercase">Record</div>
            <div class="text-[11px] text-yellow-200/90 font-mono">
                <span id="record-name">---</span>: <span id="record-val">0</span>
            </div>
        </div>
    </div>

    <div id="game-container">
        <div id="overlay">
            <div id="menu-standard">
                <i data-lucide="flame" class="w-12 h-12 text-purple-500 mb-4 mx-auto animate-pulse"></i>
                <h2 id="msg-title" class="text-xl font-bold text-white mb-2">EL LABERINTO</h2>
                <p id="msg-desc" class="text-xs text-slate-400 max-w-[200px] mx-auto">La oscuridad acecha. Recoge runas para iluminar tu camino.</p>
                <div id="bonus-alert" class="hidden mt-2 text-yellow-400 font-bold text-sm">¡BENDICIÓN RECIBIDA!</div>
                <button class="btn-primary" onclick="initGameSession()">COMENZAR</button>
            </div>

            <div id="menu-record" class="hidden">
                <i data-lucide="trophy" class="w-12 h-12 text-yellow-500 mb-4 mx-auto"></i>
                <h2 class="text-xl font-bold text-white mb-1">LEYENDA</h2>
                <p class="text-[10px] text-slate-400">Tu nombre quedará grabado en las sombras.</p>
                <input type="text" id="initials-input" maxlength="3" placeholder="---">
                <br>
                <button class="btn-primary" onclick="confirmHighScore()">GRABAR</button>
            </div>
        </div>
        <canvas id="mazeCanvas"></canvas>
    </div>

    <div id="mobile-controls">
        <div></div>
        <button class="control-btn" onpointerdown="handleTouchMove(0, -1)" aria-label="Arriba">
            <i data-lucide="chevron-up"></i>
        </button>
        <div></div>
        
        <button class="control-btn" onpointerdown="handleTouchMove(-1, 0)" aria-label="Izquierda">
            <i data-lucide="chevron-left"></i>
        </button>
        <button class="control-btn magic-btn" onpointerdown="handleTouchMagic()" aria-label="Magia">
            <i data-lucide="sparkles"></i>
        </button>
        <button class="control-btn" onpointerdown="handleTouchMove(1, 0)" aria-label="Derecha">
            <i data-lucide="chevron-right"></i>
        </button>
        
        <div></div>
        <button class="control-btn" onpointerdown="handleTouchMove(0, 1)" aria-label="Abajo">
            <i data-lucide="chevron-down"></i>
        </button>
        <div></div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const levelText = document.getElementById('level-val');
        const stagesText = document.getElementById('stages-val');
        const starsText = document.getElementById('stars-count');
        const recordNameText = document.getElementById('record-name');
        const recordValText = document.getElementById('record-val');
        const overlay = document.getElementById('overlay');
        const batteryBar = document.getElementById('battery-fill');

        let level = 1;
        let stages = 0;
        let stars = 2;
        let isMagicActive = false;
        let gameActive = false;
        let battery = 100;
        
        let grid = [];
        let cols, rows, cellSize;
        let player = {x:0, y:0};
        let exit = {x:0, y:0};
        let shadow = {x:0, y:0};
        let rune = null;

        let shadowPulse = 0;
        let timers = { shadow: null, battery: null };

        let bestScore = parseInt(localStorage.getItem('runa_best_val')) || 0;
        let bestName = localStorage.getItem('runa_best_name') || "---";

        function refreshUI() {
            recordNameText.innerText = bestName;
            recordValText.innerText = bestScore;
            starsText.innerText = stars;
            levelText.innerText = level;
            stagesText.innerText = stages;
            
            if (battery > 50) batteryBar.style.background = "#10b981";
            else if (battery > 20) batteryBar.style.background = "#f59e0b";
            else batteryBar.style.background = "#ef4444";
        }

        class Cell {
            constructor(c, r) {
                this.c = c;
                this.r = r;
                this.walls = [true, true, true, true]; 
                this.visited = false;
            }

            draw() {
                const x = this.c * cellSize;
                const y = this.r * cellSize;
                
                // MEJORA VISUAL DE MUROS PARA PC
                ctx.strokeStyle = "rgba(168, 85, 247, 0.8)"; // Más opaco
                ctx.lineWidth = Math.max(2, cellSize * 0.08); // Un poco más grueso
                ctx.shadowBlur = 4; // Resplandor sutil
                ctx.shadowColor = "rgba(168, 85, 247, 0.5)";
                
                ctx.beginPath();
                if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); }
                if (this.walls[1]) { ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); }
                if (this.walls[2]) { ctx.moveTo(x + cellSize, y + cellSize); ctx.lineTo(x, y + cellSize); }
                if (this.walls[3]) { ctx.moveTo(x, y + cellSize); ctx.lineTo(x, y); }
                ctx.stroke();
                
                // Reset de sombras para que no afecte al resto del render
                ctx.shadowBlur = 0;
            }
        }

        function createMaze() {
            grid = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    grid.push(new Cell(c, r));
                }
            }

            const stack = [];
            let current = grid[0];
            current.visited = true;

            while (true) {
                const next = getNeighbor(current);
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWallsBetween(current, next);
                    current = next;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    break;
                }
            }
        }

        function getIdx(c, r) {
            if (c < 0 || r < 0 || c >= cols || r >= rows) return -1;
            return c + r * cols;
        }

        function getNeighbor(cell) {
            const neighbors = [];
            const coords = [[0,-1],[1,0],[0,1],[-1,0]];
            coords.forEach(coord => {
                const n = grid[getIdx(cell.c + coord[0], cell.r + coord[1])];
                if (n && !n.visited) neighbors.push(n);
            });
            return neighbors.length > 0 ? neighbors[Math.floor(Math.random() * neighbors.length)] : null;
        }

        function removeWallsBetween(a, b) {
            const dc = a.c - b.c;
            if (dc === 1) { a.walls[3] = false; b.walls[1] = false; }
            else if (dc === -1) { a.walls[1] = false; b.walls[3] = false; }
            const dr = a.r - b.r;
            if (dr === 1) { a.walls[0] = false; b.walls[2] = false; }
            else if (dr === -1) { a.walls[2] = false; b.walls[0] = false; }
        }

        function prepareStage() {
            clearTimers();
            isMagicActive = false;
            
            if (level === 1) { cols = 8; rows = 8; }
            else if (level === 2) { cols = 12; rows = 10; }
            else { cols = 16; rows = 12; }

            const margin = 40;
            const availableW = Math.min(450, window.innerWidth - margin);
            const availableH = window.innerHeight * 0.5;
            
            cellSize = Math.floor(Math.min(availableW / cols, availableH / rows));
            if (cellSize < 10) cellSize = 10;

            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            createMaze();

            player = { x: 0, y: 0 };
            exit = { x: cols - 1, y: rows - 1 };
            shadow = { x: cols - 1, y: 0 };
            
            if (level > 1 && level % 2 === 0) {
                rune = { 
                    x: Math.floor(Math.random() * (cols-2)) + 1, 
                    y: Math.floor(Math.random() * (rows-2)) + 1,
                    collected: false 
                };
            } else {
                rune = null;
            }

            battery = 100;
            refreshUI();
            render();
        }

        function clearTimers() {
            clearInterval(timers.shadow);
            clearInterval(timers.battery);
        }

        function render() {
            if (!ctx || isNaN(cellSize) || cellSize <= 0) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            grid.forEach(c => c.draw());

            // Salida
            const ex = exit.x * cellSize + cellSize/2;
            const ey = exit.y * cellSize + cellSize/2;
            const exitRad = Math.max(2, cellSize/4);
            ctx.fillStyle = "#fbbf24";
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#fbbf24";
            ctx.beginPath();
            ctx.arc(ex, ey, exitRad, 0, Math.PI*2);
            ctx.fill();

            // Runa
            if (rune && !rune.collected) {
                ctx.fillStyle = "#facc15";
                ctx.shadowColor = "#facc15";
                ctx.beginPath();
                const rx = rune.x * cellSize + cellSize/2;
                const ry = rune.y * cellSize + cellSize/2;
                const runeSize = Math.max(3, cellSize/3);
                ctx.moveTo(rx, ry - runeSize);
                ctx.lineTo(rx + runeSize/1.5, ry);
                ctx.lineTo(rx, ry + runeSize);
                ctx.lineTo(rx - runeSize/1.5, ry);
                ctx.closePath();
                ctx.fill();
            }

            // Sombra
            const sx = shadow.x * cellSize + cellSize/2;
            const sy = shadow.y * cellSize + cellSize/2;
            const shadowBaseRad = Math.max(2, cellSize/3.5);
            ctx.fillStyle = "#ef4444";
            ctx.shadowColor = "#ef4444";
            ctx.shadowBlur = 10 + Math.sin(shadowPulse) * 5;
            ctx.beginPath();
            ctx.arc(sx, sy, shadowBaseRad, 0, Math.PI*2);
            ctx.fill();
            shadowPulse += 0.2;

            // Jugador
            ctx.shadowBlur = isMagicActive ? 25 : 0;
            ctx.shadowColor = isMagicActive ? "#facc15" : "transparent";
            ctx.fillStyle = isMagicActive ? "#facc15" : "#c084fc";
            const pSize = Math.max(4, cellSize * 0.6);
            const pOffset = (cellSize - pSize) / 2;
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(player.x * cellSize + pOffset, player.y * cellSize + pOffset, pSize, pSize, 4);
            } else {
                ctx.rect(player.x * cellSize + pOffset, player.y * cellSize + pOffset, pSize, pSize);
            }
            ctx.fill();
            ctx.shadowBlur = 0;

            // Linterna
            if (gameActive) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-in';
                const px = player.x * cellSize + cellSize/2;
                const py = player.y * cellSize + cellSize/2;
                
                let radius = Math.max(20, cellSize * 3.5);
                if (battery < 20 && Math.random() > 0.8) radius *= 0.6;

                const grad = ctx.createRadialGradient(px, py, 0, px, py, radius);
                grad.addColorStop(0, 'rgba(0,0,0,1)');
                grad.addColorStop(0.7, 'rgba(0,0,0,0.3)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }
        }

        function triggerMove(dc, dr) {
            if (!gameActive) return;
            const current = grid[getIdx(player.x, player.y)];
            if (!current) return;
            
            let possible = false;

            if (isMagicActive) {
                const targetX = player.x + dc;
                const targetY = player.y + dr;
                if (targetX >= 0 && targetX < cols && targetY >= 0 && targetY < rows) {
                    possible = true;
                    isMagicActive = false;
                }
            } else {
                if (dc === 1 && !current.walls[1]) possible = true;
                if (dc === -1 && !current.walls[3]) possible = true;
                if (dr === 1 && !current.walls[2]) possible = true;
                if (dr === -1 && !current.walls[0]) possible = true;
            }

            if (possible) {
                player.x += dc;
                player.y += dr;
                checkEvents();
                render();
            }
        }

        function handleTouchMove(dc, dr) {
            triggerMove(dc, dr);
        }

        function handleTouchMagic() {
            useMagicStar();
        }

        function moveShadow() {
            if (!gameActive) return;
            const current = grid[getIdx(shadow.x, shadow.y)];
            if (!current) return;
            
            const options = [];
            if (!current.walls[0]) options.push({x:0, y:-1});
            if (!current.walls[1]) options.push({x:1, y:0});
            if (!current.walls[2]) options.push({x:0, y:1});
            if (!current.walls[3]) options.push({x:-1, y:0});

            if (options.length > 0) {
                options.sort((a, b) => {
                    const distA = Math.hypot((shadow.x + a.x) - player.x, (shadow.y + a.y) - player.y);
                    const distB = Math.hypot((shadow.x + b.x) - player.x, (shadow.y + b.y) - player.y);
                    return distA - distB;
                });
                
                const move = Math.random() < 0.25 ? options[Math.floor(Math.random()*options.length)] : options[0];
                shadow.x += move.x;
                shadow.y += move.y;
                checkEvents();
                render();
            }
        }

        function checkEvents() {
            if (rune && !rune.collected && player.x === rune.x && player.y === rune.y) {
                rune.collected = true;
                stars++;
                refreshUI();
            }
            if (player.x === shadow.x && player.y === shadow.y) {
                endGame("DERROTA", "La sombra te ha reclamado.");
            }
            if (player.x === exit.x && player.y === exit.y) {
                nextLevel();
            }
        }

        function nextLevel() {
            gameActive = false;
            clearTimers();
            stages++;
            level++;
            
            let bonus = false;
            if (stages % 5 === 0) { stars += 2; bonus = true; }

            document.getElementById('msg-title').innerText = "ETAPA SUPERADA";
            document.getElementById('msg-desc').innerText = `Has avanzado a la etapa ${stages + 1}.`;
            const alert = document.getElementById('bonus-alert');
            if (bonus) alert.classList.remove('hidden'); else alert.classList.add('hidden');
            
            overlay.classList.remove('hidden');
            document.getElementById('menu-standard').classList.remove('hidden');
            document.getElementById('menu-record').classList.add('hidden');
        }

        function endGame(title, desc) {
            gameActive = false;
            clearTimers();
            render();

            if (stages > bestScore) {
                document.getElementById('menu-standard').classList.add('hidden');
                document.getElementById('menu-record').classList.remove('hidden');
                overlay.classList.remove('hidden');
            } else {
                document.getElementById('msg-title').innerText = title;
                document.getElementById('msg-desc').innerText = desc + ` Puntos: ${stages}`;
                overlay.classList.remove('hidden');
                resetSession();
            }
        }

        function resetSession() {
            stages = 0;
            level = 1;
            stars = 2;
            refreshUI();
        }

        function confirmHighScore() {
            const input = document.getElementById('initials-input');
            bestName = input.value.toUpperCase().substring(0,3) || "???";
            bestScore = stages;
            localStorage.setItem('runa_best_val', bestScore);
            localStorage.setItem('runa_best_name', bestName);
            
            resetSession();
            document.getElementById('menu-record').classList.add('hidden');
            document.getElementById('menu-standard').classList.remove('hidden');
            document.getElementById('msg-title').innerText = "RECORD GRABADO";
            refreshUI();
        }

        function useMagicStar() {
            if (stars > 0 && !isMagicActive && gameActive) {
                stars--;
                isMagicActive = true;
                refreshUI();
                render();
            }
        }

        function initGameSession() {
            overlay.classList.add('hidden');
            prepareStage();
            gameActive = true;

            const speed = Math.max(150, 700 - (stages * 25)); 
            timers.shadow = setInterval(moveShadow, speed);

            timers.battery = setInterval(() => {
                battery -= (0.3 + (stages * 0.025)); 
                batteryBar.style.width = Math.max(0, battery) + "%";
                if (battery <= 0) {
                    endGame("EXTINCIÓN", "Tu linterna se ha quedado sin energía.");
                }
            }, 150);
        }

        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            if (e.code === 'Space') {
                e.preventDefault();
                useMagicStar();
            }
            const keys = {
                'ArrowUp': [0, -1], 'w': [0, -1],
                'ArrowDown': [0, 1], 's': [0, 1],
                'ArrowLeft': [-1, 0], 'a': [-1, 0],
                'ArrowRight': [1, 0], 'd': [1, 0]
            };
            if (keys[e.key]) {
                e.preventDefault();
                triggerMove(...keys[e.key]);
            }
        });

        window.onload = () => {
            lucide.createIcons();
            refreshUI();
            prepareStage();
        };

        window.addEventListener('resize', () => {
            if (!gameActive) prepareStage();
        });
    </script>
</body>
</html>
